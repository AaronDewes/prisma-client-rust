// Code generated by Prisma Client Rust. DO NOT EDIT.

use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::{
    transform_equals, Field, Input, Output, Query, QueryContext, Result as QueryResult,
};
use prisma_client_rust::query_core::{
    executor, schema_builder, BuildMode, CoreError, QueryExecutor, QuerySchema,
};
use prisma_client_rust::{chrono, operator::Operator, serde_json, DeleteResult, Direction};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> PrismaClient {
    let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:../dev.db\"\n}\n\ngenerator client {\n    provider      = \"prisma-client-rust\"\n    binaryTargets = [\"native\"]\n    output        = \"../src/db.rs\"\n}\n\nmodel User {\n    id          String   @id\n    displayName String\n\n    posts Post[]\n}\n\nmodel Post {\n    id      String @id\n    content String\n\n    user   User   @relation(fields: [userId], references: [id])\n    userId String\n}\n" ;
    let config = parse_configuration(datamodel_str).unwrap().subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url().unwrap() {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok()).unwrap()
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> PrismaClient {
    let datamodel_str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:../dev.db\"\n}\n\ngenerator client {\n    provider      = \"prisma-client-rust\"\n    binaryTargets = [\"native\"]\n    output        = \"../src/db.rs\"\n}\n\nmodel User {\n    id          String   @id\n    displayName String\n\n    posts Post[]\n}\n\nmodel Post {\n    id      String @id\n    content String\n\n    user   User   @relation(fields: [userId], references: [id])\n    userId String\n}\n" ;
    let config = parse_configuration(datamodel_str).unwrap().subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await.unwrap();
    let internal_model = InternalDataModelBuilder::new(&datamodel_str).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await.unwrap();
    PrismaClient {
        executor,
        query_schema,
    }
}
impl PrismaClient {
    pub async fn _query_raw<T: serde::de::DeserializeOwned>(
        &self,
        query: &str,
    ) -> QueryResult<Vec<T>> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "queryRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await
    }
    pub async fn _execute_raw(&self, query: &str) -> QueryResult<i64> {
        let query = Query {
            ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
            operation: "mutation".into(),
            method: "executeRaw".into(),
            inputs: vec![
                Input {
                    name: "query".into(),
                    value: Some(query.into()),
                    ..Default::default()
                },
                Input {
                    name: "parameters".into(),
                    value: Some("[]".into()),
                    ..Default::default()
                },
            ],
            name: "".into(),
            model: "".into(),
            outputs: vec![],
        };
        query.perform().await.map(|result: i64| result)
    }
    pub fn user(&self) -> UserActions {
        UserActions { client: &self }
    }
    pub fn post(&self) -> PostActions {
        PostActions { client: &self }
    }
}
fn user_outputs() -> Vec<Output> {
    vec![Output::new("id"), Output::new("displayName")]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "displayName")]
    pub display_name: String,
    #[serde(rename = "posts")]
    posts: Option<Vec<PostData>>,
}
impl UserData {
    pub fn posts(&self) -> Result<&Vec<PostData>, String> {
        match self.posts.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "Attempted to access posts but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct User;
impl User {
    pub fn id() -> UserIdField {
        UserIdField {}
    }
    pub fn display_name() -> UserDisplayNameField {
        UserDisplayNameField {}
    }
    pub fn posts() -> UserPostsField {
        UserPostsField {}
    }
}
pub struct UserIdField {}
pub struct UserSetId(String);
impl From<UserSetId> for UserSetParam {
    fn from(value: UserSetId) -> Self {
        Self::Id(value.0)
    }
}
impl UserIdField {
    pub fn contains(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> UserWhereParam {
        UserWhereParam::IdHasSuffix(value)
    }
    pub fn equals<T: From<UserUniqueWhereParam>>(&self, value: String) -> T {
        UserUniqueWhereParam::IdEquals(value).into()
    }
    pub fn set<T: From<UserSetId>>(&self, value: String) -> T {
        UserSetId(value).into()
    }
    pub fn order(&self, direction: Direction) -> UserOrderByParam {
        UserOrderByParam::Id(direction)
    }
}
pub struct UserDisplayNameField {}
pub struct UserSetDisplayName(String);
impl From<UserSetDisplayName> for UserSetParam {
    fn from(value: UserSetDisplayName) -> Self {
        Self::DisplayName(value.0)
    }
}
impl UserDisplayNameField {
    pub fn contains(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameContains(value)
    }
    pub fn has_prefix(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> UserWhereParam {
        UserWhereParam::DisplayNameEquals(value).into()
    }
    pub fn set<T: From<UserSetDisplayName>>(&self, value: String) -> T {
        UserSetDisplayName(value).into()
    }
    pub fn order(&self, direction: Direction) -> UserOrderByParam {
        UserOrderByParam::DisplayName(direction)
    }
}
pub struct UserPostsField {}
pub struct UserLinkPosts(Vec<PostWhereParam>);
impl From<UserLinkPosts> for UserSetParam {
    fn from(value: UserLinkPosts) -> Self {
        Self::LinkPosts(value.0.into_iter().map(|v| v.into()).collect())
    }
}
impl UserPostsField {
    pub fn some(&self, value: Vec<PostWhereParam>) -> UserWhereParam {
        UserWhereParam::PostsSome(value)
    }
    pub fn every(&self, value: Vec<PostWhereParam>) -> UserWhereParam {
        UserWhereParam::PostsEvery(value)
    }
    pub fn link<T: From<UserLinkPosts>>(&self, value: Vec<PostWhereParam>) -> T {
        UserLinkPosts(value).into()
    }
    pub fn unlink(&self, params: Vec<PostWhereParam>) -> UserSetParam {
        UserSetParam::UnlinkPosts(params)
    }
    pub fn fetch(&self, params: Vec<PostWhereParam>) -> UserWithParam {
        UserWithParam::Posts(params)
    }
}
pub enum UserWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    DisplayNameContains(String),
    DisplayNameHasPrefix(String),
    DisplayNameHasSuffix(String),
    DisplayNameEquals(String),
    PostsSome(Vec<PostWhereParam>),
    PostsEvery(Vec<PostWhereParam>),
    Not(Vec<UserWhereParam>),
    Or(Vec<UserWhereParam>),
    And(Vec<UserWhereParam>),
}
impl UserWhereParam {
    pub fn to_field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameContains(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameHasPrefix(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameHasSuffix(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::DisplayNameEquals(value) => Field {
                name: "displayName".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostsSome(value) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::PostsEvery(value) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                ..Default::default()
            },
        }
    }
}
impl From<Operator<Self>> for UserWhereParam {
    fn from(op: Operator<Self>) -> Self {
        match op {
            Operator::Not(value) => Self::Not(value),
            Operator::And(value) => Self::And(value),
            Operator::Or(value) => Self::Or(value),
        }
    }
}
pub enum UserUniqueWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
}
impl From<UserUniqueWhereParam> for UserWhereParam {
    fn from(op: UserUniqueWhereParam) -> Self {
        match op {
            UserUniqueWhereParam::IdContains(value) => Self::IdContains(value),
            UserUniqueWhereParam::IdHasPrefix(value) => Self::IdHasPrefix(value),
            UserUniqueWhereParam::IdHasSuffix(value) => Self::IdHasSuffix(value),
            UserUniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
        }
    }
}
pub enum UserWithParam {
    Posts(Vec<PostWhereParam>),
}
impl UserWithParam {
    pub fn to_output(self) -> Output {
        match self {
            Self::Posts(where_params) => Output {
                name: "posts".into(),
                outputs: post_outputs(),
                inputs: if where_params.len() > 0 {
                    vec![Input {
                        name: "where".into(),
                        fields: where_params.into_iter().map(|f| f.to_field()).collect(),
                        ..Default::default()
                    }]
                } else {
                    vec![]
                },
                ..Default::default()
            },
        }
    }
}
pub enum UserSetParam {
    Id(String),
    DisplayName(String),
    LinkPosts(Vec<PostWhereParam>),
    UnlinkPosts(Vec<PostWhereParam>),
}
impl UserSetParam {
    pub fn to_field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DisplayName(value) => Field {
                name: "displayName".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkPosts(where_params) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(
                        where_params
                            .into_iter()
                            .map(|item| item.to_field())
                            .collect(),
                    )),
                    list: true,
                    wrap_list: true,
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UnlinkPosts(where_params) => Field {
                name: "posts".into(),
                fields: Some(vec![Field {
                    name: "disconnect".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(transform_equals(
                        where_params
                            .into_iter()
                            .map(|item| item.to_field())
                            .collect(),
                    )),
                    ..Default::default()
                }]),
                ..Default::default()
            },
        }
    }
}
pub enum UserOrderByParam {
    Id(Direction),
    DisplayName(Direction),
}
impl UserOrderByParam {
    pub fn to_field(self) -> Field {
        match self {
            Self::Id(direction) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(direction).unwrap()),
                ..Default::default()
            },
            Self::DisplayName(direction) => Field {
                name: "displayName".into(),
                value: Some(serde_json::to_value(direction).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub enum UserCursor {
    Id(String),
    DisplayName(String),
}
impl UserCursor {
    fn to_field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::DisplayName(value) => Field {
                name: "displayName".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub struct UserFindMany<'a> {
    query: Query<'a>,
    order_by_params: Vec<UserOrderByParam>,
    with_params: Vec<UserWithParam>,
}
impl<'a> UserFindMany<'a> {
    pub async fn exec(self) -> QueryResult<Vec<UserData>> {
        let Self {
            mut query,
            order_by_params,
            with_params,
        } = self;
        if order_by_params.len() > 0 {
            query.inputs.push(Input {
                name: "orderBy".into(),
                fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                ..Default::default()
            });
        }
        query.outputs.extend(
            with_params
                .into_iter()
                .map(|f| f.to_output())
                .collect::<Vec<_>>(),
        );
        query.perform().await
    }
    pub fn delete(self) -> UserDelete<'a> {
        UserDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "User".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<UserSetParam>) -> UserUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.to_field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        UserUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
            with_params: vec![],
        }
    }
    pub fn order_by(mut self, param: UserOrderByParam) -> Self {
        self.order_by_params.push(param);
        self
    }
    pub fn with(mut self, param: UserWithParam) -> Self {
        self.with_params.push(param);
        self
    }
    pub fn skip(mut self, skip: usize) -> Self {
        self.query.inputs.push(Input {
            name: "skip".into(),
            value: Some(serde_json::to_value(skip).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn take(mut self, take: usize) -> Self {
        self.query.inputs.push(Input {
            name: "take".into(),
            value: Some(serde_json::to_value(take).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn cursor(mut self, cursor: UserCursor) -> Self {
        self.query.inputs.push(Input {
            name: "cursor".into(),
            fields: vec![cursor.to_field()],
            ..Default::default()
        });
        self
    }
}
pub struct UserFindFirst<'a> {
    query: Query<'a>,
    order_by_params: Vec<UserOrderByParam>,
    with_params: Vec<UserWithParam>,
}
impl<'a> UserFindFirst<'a> {
    pub async fn exec(self) -> QueryResult<UserData> {
        let Self {
            mut query,
            order_by_params,
            with_params,
        } = self;
        if order_by_params.len() > 0 {
            query.inputs.push(Input {
                name: "orderBy".into(),
                fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                ..Default::default()
            });
        }
        query.outputs.extend(
            with_params
                .into_iter()
                .map(|f| f.to_output())
                .collect::<Vec<_>>(),
        );
        query.perform().await
    }
    pub fn with(mut self, param: UserWithParam) -> Self {
        self.with_params.push(param);
        self
    }
    pub fn order_by(mut self, param: UserOrderByParam) -> Self {
        self.order_by_params.push(param);
        self
    }
    pub fn skip(mut self, skip: usize) -> Self {
        self.query.inputs.push(Input {
            name: "skip".into(),
            value: Some(serde_json::to_value(skip).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn take(mut self, take: usize) -> Self {
        self.query.inputs.push(Input {
            name: "take".into(),
            value: Some(serde_json::to_value(take).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn cursor(mut self, cursor: UserCursor) -> Self {
        self.query.inputs.push(Input {
            name: "cursor".into(),
            fields: vec![cursor.to_field()],
            ..Default::default()
        });
        self
    }
}
pub struct UserFindUnique<'a> {
    query: Query<'a>,
    with_params: Vec<UserWithParam>,
}
impl<'a> UserFindUnique<'a> {
    pub async fn exec(self) -> QueryResult<UserData> {
        let Self {
            mut query,
            with_params,
        } = self;
        query.outputs.extend(
            with_params
                .into_iter()
                .map(|f| f.to_output())
                .collect::<Vec<_>>(),
        );
        query.perform().await
    }
    pub fn delete(self) -> UserDelete<'a> {
        UserDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "User".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<UserSetParam>) -> UserUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.to_field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        UserUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
            with_params: vec![],
        }
    }
    pub fn with(mut self, param: UserWithParam) -> Self {
        self.with_params.push(param);
        self
    }
}
pub struct UserCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> UserCreateOne<'a> {
    pub async fn exec(self) -> QueryResult<UserData> {
        self.query.perform().await
    }
}
pub struct UserUpdateUnique<'a> {
    query: Query<'a>,
    with_params: Vec<UserWithParam>,
}
impl<'a> UserUpdateUnique<'a> {
    pub async fn exec(self) -> QueryResult<UserData> {
        self.query.perform().await
    }
    pub fn with(mut self, param: UserWithParam) -> Self {
        self.with_params.push(param);
        self
    }
}
pub struct UserUpdateMany<'a> {
    query: Query<'a>,
    with_params: Vec<UserWithParam>,
}
impl<'a> UserUpdateMany<'a> {
    pub async fn exec(self) -> QueryResult<Vec<UserData>> {
        self.query.perform().await
    }
    pub fn with(mut self, param: UserWithParam) -> Self {
        self.with_params.push(param);
        self
    }
}
pub struct UserUpsertOne<'a> {
    query: Query<'a>,
}
impl<'a> UserUpsertOne<'a> {
    pub async fn exec(self) -> QueryResult<UserData> {
        self.query.perform().await
    }
    pub fn create(
        mut self,
        id: UserSetId,
        display_name: UserSetDisplayName,
        params: Vec<UserSetParam>,
    ) -> Self {
        let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
        input_fields.push(UserSetParam::from(id).to_field());
        input_fields.push(UserSetParam::from(display_name).to_field());
        self.query.inputs.push(Input {
            name: "create".into(),
            fields: input_fields,
            ..Default::default()
        });
        self
    }
    pub fn update(mut self, params: Vec<UserSetParam>) -> Self {
        self.query.inputs.push(Input {
            name: "update".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.to_field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        self
    }
}
pub struct UserDelete<'a> {
    query: Query<'a>,
}
impl<'a> UserDelete<'a> {
    pub async fn exec(self) -> QueryResult<isize> {
        self.query.perform::<DeleteResult>().await.map(|r| r.count)
    }
}
pub struct UserActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> UserActions<'a> {
    pub fn find_unique(&self, param: UserUniqueWhereParam) -> UserFindUnique {
        let param: UserWhereParam = param.into();
        let fields = transform_equals(vec![param.to_field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        UserFindUnique {
            query,
            with_params: vec![],
        }
    }
    pub fn find_first(&self, params: Vec<UserWhereParam>) -> UserFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs,
        };
        UserFindFirst {
            query,
            order_by_params: vec![],
            with_params: vec![],
        }
    }
    pub fn find_many(&self, params: Vec<UserWhereParam>) -> UserFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs,
        };
        UserFindMany {
            query,
            order_by_params: vec![],
            with_params: vec![],
        }
    }
    pub fn create_one(
        &self,
        id: UserSetId,
        display_name: UserSetDisplayName,
        params: Vec<UserSetParam>,
    ) -> UserCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
        input_fields.push(UserSetParam::from(id).to_field());
        input_fields.push(UserSetParam::from(display_name).to_field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        UserCreateOne { query }
    }
    pub fn upsert_one(&self, param: UserUniqueWhereParam) -> UserUpsertOne {
        let param: UserWhereParam = param.into();
        let fields = transform_equals(vec![param.to_field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "upsertOne".into(),
            model: "User".into(),
            outputs: user_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        UserUpsertOne { query }
    }
}
fn post_outputs() -> Vec<Output> {
    vec![
        Output::new("id"),
        Output::new("content"),
        Output::new("userId"),
    ]
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostData {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "content")]
    pub content: String,
    #[serde(rename = "user")]
    user: Box<Option<UserData>>,
    #[serde(rename = "userId")]
    pub user_id: String,
}
impl PostData {
    pub fn user(&self) -> Result<&UserData, String> {
        match self.user.as_ref() {
            Some(v) => Ok(v),
            None => Err(
                "Attempted to access user but did not fetch it using the .with() syntax"
                    .to_string(),
            ),
        }
    }
}
pub struct Post;
impl Post {
    pub fn id() -> PostIdField {
        PostIdField {}
    }
    pub fn content() -> PostContentField {
        PostContentField {}
    }
    pub fn user() -> PostUserField {
        PostUserField {}
    }
    pub fn user_id() -> PostUserIdField {
        PostUserIdField {}
    }
}
pub struct PostIdField {}
pub struct PostSetId(String);
impl From<PostSetId> for PostSetParam {
    fn from(value: PostSetId) -> Self {
        Self::Id(value.0)
    }
}
impl PostIdField {
    pub fn contains(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PostWhereParam {
        PostWhereParam::IdHasSuffix(value)
    }
    pub fn equals<T: From<PostUniqueWhereParam>>(&self, value: String) -> T {
        PostUniqueWhereParam::IdEquals(value).into()
    }
    pub fn set<T: From<PostSetId>>(&self, value: String) -> T {
        PostSetId(value).into()
    }
    pub fn order(&self, direction: Direction) -> PostOrderByParam {
        PostOrderByParam::Id(direction)
    }
}
pub struct PostContentField {}
pub struct PostSetContent(String);
impl From<PostSetContent> for PostSetParam {
    fn from(value: PostSetContent) -> Self {
        Self::Content(value.0)
    }
}
impl PostContentField {
    pub fn contains(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PostWhereParam {
        PostWhereParam::ContentEquals(value).into()
    }
    pub fn set<T: From<PostSetContent>>(&self, value: String) -> T {
        PostSetContent(value).into()
    }
    pub fn order(&self, direction: Direction) -> PostOrderByParam {
        PostOrderByParam::Content(direction)
    }
}
pub struct PostUserField {}
pub struct PostLinkUser(UserWhereParam);
impl From<PostLinkUser> for PostSetParam {
    fn from(value: PostLinkUser) -> Self {
        Self::LinkUser(value.0)
    }
}
impl PostUserField {
    pub fn is(&self, value: Vec<UserWhereParam>) -> PostWhereParam {
        PostWhereParam::UserIs(value)
    }
    pub fn link<T: From<PostLinkUser>>(&self, value: UserWhereParam) -> T {
        PostLinkUser(value).into()
    }
    pub fn fetch(&self) -> PostWithParam {
        PostWithParam::User
    }
}
pub struct PostUserIdField {}
pub struct PostSetUserId(String);
impl From<PostSetUserId> for PostSetParam {
    fn from(value: PostSetUserId) -> Self {
        Self::UserId(value.0)
    }
}
impl PostUserIdField {
    pub fn contains(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserIdContains(value)
    }
    pub fn has_prefix(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserIdHasPrefix(value)
    }
    pub fn has_suffix(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserIdHasSuffix(value)
    }
    pub fn equals(&self, value: String) -> PostWhereParam {
        PostWhereParam::UserIdEquals(value).into()
    }
    pub fn set<T: From<PostSetUserId>>(&self, value: String) -> T {
        PostSetUserId(value).into()
    }
    pub fn order(&self, direction: Direction) -> PostOrderByParam {
        PostOrderByParam::UserId(direction)
    }
}
pub enum PostWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
    ContentContains(String),
    ContentHasPrefix(String),
    ContentHasSuffix(String),
    ContentEquals(String),
    UserIs(Vec<UserWhereParam>),
    UserIdContains(String),
    UserIdHasPrefix(String),
    UserIdHasSuffix(String),
    UserIdEquals(String),
    Not(Vec<PostWhereParam>),
    Or(Vec<PostWhereParam>),
    And(Vec<PostWhereParam>),
}
impl PostWhereParam {
    pub fn to_field(self) -> Field {
        match self {
            Self::IdContains(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasPrefix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdHasSuffix(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::IdEquals(value) => Field {
                name: "id".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentContains(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentHasPrefix(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentHasSuffix(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::ContentEquals(value) => Field {
                name: "content".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIs(value) => Field {
                name: "user".into(),
                fields: Some(vec![Field {
                    name: "AND".into(),
                    fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIdContains(value) => Field {
                name: "userId".into(),
                fields: Some(vec![Field {
                    name: "contains".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIdHasPrefix(value) => Field {
                name: "userId".into(),
                fields: Some(vec![Field {
                    name: "starts_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIdHasSuffix(value) => Field {
                name: "userId".into(),
                fields: Some(vec![Field {
                    name: "ends_with".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserIdEquals(value) => Field {
                name: "userId".into(),
                fields: Some(vec![Field {
                    name: "equals".into(),
                    value: Some(serde_json::to_value(value).unwrap()),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::Not(value) => Field {
                name: "NOT".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                ..Default::default()
            },
            Self::Or(value) => Field {
                name: "OR".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                ..Default::default()
            },
            Self::And(value) => Field {
                name: "AND".into(),
                list: true,
                wrap_list: true,
                fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
                ..Default::default()
            },
        }
    }
}
impl From<Operator<Self>> for PostWhereParam {
    fn from(op: Operator<Self>) -> Self {
        match op {
            Operator::Not(value) => Self::Not(value),
            Operator::And(value) => Self::And(value),
            Operator::Or(value) => Self::Or(value),
        }
    }
}
pub enum PostUniqueWhereParam {
    IdContains(String),
    IdHasPrefix(String),
    IdHasSuffix(String),
    IdEquals(String),
}
impl From<PostUniqueWhereParam> for PostWhereParam {
    fn from(op: PostUniqueWhereParam) -> Self {
        match op {
            PostUniqueWhereParam::IdContains(value) => Self::IdContains(value),
            PostUniqueWhereParam::IdHasPrefix(value) => Self::IdHasPrefix(value),
            PostUniqueWhereParam::IdHasSuffix(value) => Self::IdHasSuffix(value),
            PostUniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
        }
    }
}
pub enum PostWithParam {
    User,
}
impl PostWithParam {
    pub fn to_output(self) -> Output {
        match self {
            Self::User => Output {
                name: "user".into(),
                outputs: user_outputs(),
                ..Default::default()
            },
        }
    }
}
pub enum PostSetParam {
    Id(String),
    Content(String),
    LinkUser(UserWhereParam),
    UserId(String),
}
impl PostSetParam {
    pub fn to_field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Content(value) => Field {
                name: "content".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::LinkUser(where_param) => Field {
                name: "user".into(),
                fields: Some(vec![Field {
                    name: "connect".into(),
                    fields: Some(transform_equals(vec![where_param.to_field()])),
                    ..Default::default()
                }]),
                ..Default::default()
            },
            Self::UserId(value) => Field {
                name: "userId".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub enum PostOrderByParam {
    Id(Direction),
    Content(Direction),
    UserId(Direction),
}
impl PostOrderByParam {
    pub fn to_field(self) -> Field {
        match self {
            Self::Id(direction) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(direction).unwrap()),
                ..Default::default()
            },
            Self::Content(direction) => Field {
                name: "content".into(),
                value: Some(serde_json::to_value(direction).unwrap()),
                ..Default::default()
            },
            Self::UserId(direction) => Field {
                name: "userId".into(),
                value: Some(serde_json::to_value(direction).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub enum PostCursor {
    Id(String),
    Content(String),
    UserId(String),
}
impl PostCursor {
    fn to_field(self) -> Field {
        match self {
            Self::Id(value) => Field {
                name: "id".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::Content(value) => Field {
                name: "content".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
            Self::UserId(value) => Field {
                name: "userId".into(),
                value: Some(serde_json::to_value(value).unwrap()),
                ..Default::default()
            },
        }
    }
}
pub struct PostFindMany<'a> {
    query: Query<'a>,
    order_by_params: Vec<PostOrderByParam>,
    with_params: Vec<PostWithParam>,
}
impl<'a> PostFindMany<'a> {
    pub async fn exec(self) -> QueryResult<Vec<PostData>> {
        let Self {
            mut query,
            order_by_params,
            with_params,
        } = self;
        if order_by_params.len() > 0 {
            query.inputs.push(Input {
                name: "orderBy".into(),
                fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                ..Default::default()
            });
        }
        query.outputs.extend(
            with_params
                .into_iter()
                .map(|f| f.to_output())
                .collect::<Vec<_>>(),
        );
        query.perform().await
    }
    pub fn delete(self) -> PostDelete<'a> {
        PostDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteMany".into(),
                model: "Post".into(),
                outputs: vec![Output::new("count")],
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<PostSetParam>) -> PostUpdateMany<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.to_field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        PostUpdateMany {
            query: Query {
                operation: "mutation".into(),
                method: "updateMany".into(),
                ..self.query
            },
            with_params: vec![],
        }
    }
    pub fn order_by(mut self, param: PostOrderByParam) -> Self {
        self.order_by_params.push(param);
        self
    }
    pub fn with(mut self, param: PostWithParam) -> Self {
        self.with_params.push(param);
        self
    }
    pub fn skip(mut self, skip: usize) -> Self {
        self.query.inputs.push(Input {
            name: "skip".into(),
            value: Some(serde_json::to_value(skip).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn take(mut self, take: usize) -> Self {
        self.query.inputs.push(Input {
            name: "take".into(),
            value: Some(serde_json::to_value(take).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn cursor(mut self, cursor: PostCursor) -> Self {
        self.query.inputs.push(Input {
            name: "cursor".into(),
            fields: vec![cursor.to_field()],
            ..Default::default()
        });
        self
    }
}
pub struct PostFindFirst<'a> {
    query: Query<'a>,
    order_by_params: Vec<PostOrderByParam>,
    with_params: Vec<PostWithParam>,
}
impl<'a> PostFindFirst<'a> {
    pub async fn exec(self) -> QueryResult<PostData> {
        let Self {
            mut query,
            order_by_params,
            with_params,
        } = self;
        if order_by_params.len() > 0 {
            query.inputs.push(Input {
                name: "orderBy".into(),
                fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
                ..Default::default()
            });
        }
        query.outputs.extend(
            with_params
                .into_iter()
                .map(|f| f.to_output())
                .collect::<Vec<_>>(),
        );
        query.perform().await
    }
    pub fn with(mut self, param: PostWithParam) -> Self {
        self.with_params.push(param);
        self
    }
    pub fn order_by(mut self, param: PostOrderByParam) -> Self {
        self.order_by_params.push(param);
        self
    }
    pub fn skip(mut self, skip: usize) -> Self {
        self.query.inputs.push(Input {
            name: "skip".into(),
            value: Some(serde_json::to_value(skip).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn take(mut self, take: usize) -> Self {
        self.query.inputs.push(Input {
            name: "take".into(),
            value: Some(serde_json::to_value(take).unwrap()),
            ..Default::default()
        });
        self
    }
    pub fn cursor(mut self, cursor: PostCursor) -> Self {
        self.query.inputs.push(Input {
            name: "cursor".into(),
            fields: vec![cursor.to_field()],
            ..Default::default()
        });
        self
    }
}
pub struct PostFindUnique<'a> {
    query: Query<'a>,
    with_params: Vec<PostWithParam>,
}
impl<'a> PostFindUnique<'a> {
    pub async fn exec(self) -> QueryResult<PostData> {
        let Self {
            mut query,
            with_params,
        } = self;
        query.outputs.extend(
            with_params
                .into_iter()
                .map(|f| f.to_output())
                .collect::<Vec<_>>(),
        );
        query.perform().await
    }
    pub fn delete(self) -> PostDelete<'a> {
        PostDelete {
            query: Query {
                operation: "mutation".into(),
                method: "deleteOne".into(),
                model: "Post".into(),
                ..self.query
            },
        }
    }
    pub fn update(mut self, params: Vec<PostSetParam>) -> PostUpdateUnique<'a> {
        self.query.inputs.push(Input {
            name: "data".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.to_field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        PostUpdateUnique {
            query: Query {
                operation: "mutation".into(),
                method: "updateOne".into(),
                ..self.query
            },
            with_params: vec![],
        }
    }
    pub fn with(mut self, param: PostWithParam) -> Self {
        self.with_params.push(param);
        self
    }
}
pub struct PostCreateOne<'a> {
    query: Query<'a>,
}
impl<'a> PostCreateOne<'a> {
    pub async fn exec(self) -> QueryResult<PostData> {
        self.query.perform().await
    }
}
pub struct PostUpdateUnique<'a> {
    query: Query<'a>,
    with_params: Vec<PostWithParam>,
}
impl<'a> PostUpdateUnique<'a> {
    pub async fn exec(self) -> QueryResult<PostData> {
        self.query.perform().await
    }
    pub fn with(mut self, param: PostWithParam) -> Self {
        self.with_params.push(param);
        self
    }
}
pub struct PostUpdateMany<'a> {
    query: Query<'a>,
    with_params: Vec<PostWithParam>,
}
impl<'a> PostUpdateMany<'a> {
    pub async fn exec(self) -> QueryResult<Vec<PostData>> {
        self.query.perform().await
    }
    pub fn with(mut self, param: PostWithParam) -> Self {
        self.with_params.push(param);
        self
    }
}
pub struct PostUpsertOne<'a> {
    query: Query<'a>,
}
impl<'a> PostUpsertOne<'a> {
    pub async fn exec(self) -> QueryResult<PostData> {
        self.query.perform().await
    }
    pub fn create(
        mut self,
        id: PostSetId,
        content: PostSetContent,
        user: PostLinkUser,
        params: Vec<PostSetParam>,
    ) -> Self {
        let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
        input_fields.push(PostSetParam::from(id).to_field());
        input_fields.push(PostSetParam::from(content).to_field());
        input_fields.push(PostSetParam::from(user).to_field());
        self.query.inputs.push(Input {
            name: "create".into(),
            fields: input_fields,
            ..Default::default()
        });
        self
    }
    pub fn update(mut self, params: Vec<UserSetParam>) -> Self {
        self.query.inputs.push(Input {
            name: "update".into(),
            fields: params
                .into_iter()
                .map(|param| {
                    let mut field = param.to_field();
                    if let Some(value) = field.value {
                        field.fields = Some(vec![Field {
                            name: "set".into(),
                            value: Some(value),
                            ..Default::default()
                        }]);
                        field.value = None;
                    }
                    field
                })
                .collect(),
            ..Default::default()
        });
        self
    }
}
pub struct PostDelete<'a> {
    query: Query<'a>,
}
impl<'a> PostDelete<'a> {
    pub async fn exec(self) -> QueryResult<isize> {
        self.query.perform::<DeleteResult>().await.map(|r| r.count)
    }
}
pub struct PostActions<'a> {
    client: &'a PrismaClient,
}
impl<'a> PostActions<'a> {
    pub fn find_unique(&self, param: PostUniqueWhereParam) -> PostFindUnique {
        let param: PostWhereParam = param.into();
        let fields = transform_equals(vec![param.to_field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findUnique".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        PostFindUnique {
            query,
            with_params: vec![],
        }
    }
    pub fn find_first(&self, params: Vec<PostWhereParam>) -> PostFindFirst {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: vec![Field {
                    name: "AND".into(),
                    list: true,
                    wrap_list: true,
                    fields: Some(where_fields),
                    ..Default::default()
                }],
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findFirst".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs,
        };
        PostFindFirst {
            query,
            order_by_params: vec![],
            with_params: vec![],
        }
    }
    pub fn find_many(&self, params: Vec<PostWhereParam>) -> PostFindMany {
        let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
        let inputs = if where_fields.len() > 0 {
            vec![Input {
                name: "where".into(),
                fields: where_fields,
                ..Default::default()
            }]
        } else {
            Vec::new()
        };
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "query".into(),
            method: "findMany".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs,
        };
        PostFindMany {
            query,
            order_by_params: vec![],
            with_params: vec![],
        }
    }
    pub fn create_one(
        &self,
        id: PostSetId,
        content: PostSetContent,
        user: PostLinkUser,
        params: Vec<PostSetParam>,
    ) -> PostCreateOne {
        let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
        input_fields.push(PostSetParam::from(id).to_field());
        input_fields.push(PostSetParam::from(content).to_field());
        input_fields.push(PostSetParam::from(user).to_field());
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "createOne".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs: vec![Input {
                name: "data".into(),
                fields: input_fields,
                ..Default::default()
            }],
        };
        PostCreateOne { query }
    }
    pub fn upsert_one(&self, param: PostUniqueWhereParam) -> PostUpsertOne {
        let param: PostWhereParam = param.into();
        let fields = transform_equals(vec![param.to_field()]);
        let query = Query {
            ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
            name: String::new(),
            operation: "mutation".into(),
            method: "upsertOne".into(),
            model: "Post".into(),
            outputs: post_outputs(),
            inputs: vec![Input {
                name: "where".into(),
                fields,
                ..Default::default()
            }],
        };
        PostUpsertOne { query }
    }
}
